package org.key_project.jmlediting.core.profile.persistence.internal;

import static org.key_project.jmlediting.core.profile.persistence.internal.XMLConstants.BUNDLE;
import static org.key_project.jmlediting.core.profile.persistence.internal.XMLConstants.CLASS;
import static org.key_project.jmlediting.core.profile.persistence.internal.XMLConstants.CLASS_REFERENCE;

import org.eclipse.core.runtime.Platform;
import org.key_project.jmlediting.core.profile.persistence.ProfilePersistenceException;
import org.osgi.framework.Bundle;
import org.osgi.framework.FrameworkUtil;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

/**
 * Utility class which provides support for storing references to classes.
 * Classes are stored by name and OSGI bundle they were located from (if any).
 *
 * @author Moritz Lichter
 *
 */
public final class ClassReferencePersistence {

   /** No instances. */
   private ClassReferencePersistence() {
   }

   /**
    * Persists a reference to the given class. This contains the qualified class
    * name of the symbolic name of the OSGI bundle of the class, if the class is
    * from some. The result is an XML element with name {@link #CLASS_REFERENCE}
    * .
    *
    * @param classToPersist
    *           the class to persists a reference to
    * @param doc
    *           the parent document of the element to create
    * @return an element containing a reference to this class
    */
   public static Element persistClassReference(final Class<?> classToPersist,
         final Document doc) {
      final Element classRefElement = doc.createElement(CLASS_REFERENCE);
      // Get class name and bundle and but them into the element
      final Bundle bundle = FrameworkUtil.getBundle(classToPersist);
      if (bundle != null && bundle.getSymbolicName() != null) {
         classRefElement.setAttribute(BUNDLE, bundle.getSymbolicName());
      }
      classRefElement.setAttribute(CLASS, classToPersist.getName());
      return classRefElement;
   }

   /**
    * Returns a class which was referenced by the given element generated by
    * {@link #persistClassReference(Class, Document)}. This method ensures that
    * the returned class if a subclass of the given class.
    *
    * @param <T>
    *           the type which the returned class is guaranteed to have
    * @param classElement
    *           the element which contains the reference to the class
    * @param superClass
    *           the superclass (or same) as the returned class
    * @return the referenced class
    * @throws ProfilePersistenceException
    *            if no class can be read or the read class is not a sub class
    *            (or equal) of the given one.
    */
   @SuppressWarnings("unchecked")
   public static <T> Class<? extends T> loadClassReference(
         final Element classElement, final Class<T> superClass)
         throws ProfilePersistenceException {
      if (!(classElement.getNodeName().equals(CLASS_REFERENCE))) {
         throw new ProfilePersistenceException("Unable tag for class reference");
      }
      // Get the class name, which is required
      final String className = classElement.getAttribute(CLASS);
      if ("".equals(className)) {
         throw new ProfilePersistenceException(
               "No keyword class specified for the coded keyword node");
      }
      // Get the bundle name
      final String bundleId = classElement.getAttribute(BUNDLE);
      Class<?> loadedClass;
      try {
         // Load from Bundle if bundle name is given
         if (!"".equals(bundleId)) {
            loadedClass = Platform.getBundle(bundleId).loadClass(className);
         }
         else {
            loadedClass = Class.forName(className);
         }
         // Validate the type
         if (!superClass.isAssignableFrom(loadedClass)) {
            throw new ProfilePersistenceException(
                  "Loaded class is not a subclass of " + superClass.getName());
         }
         return (Class<? extends T>) loadedClass;
      }
      catch (final ClassNotFoundException e) {
         throw new ProfilePersistenceException("Unable to load class", e);
      }
   }

}
