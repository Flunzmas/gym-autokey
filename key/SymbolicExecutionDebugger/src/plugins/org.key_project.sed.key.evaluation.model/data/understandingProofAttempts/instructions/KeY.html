<html>   <head>      <title>KeY</title>      <link rel="stylesheet" href="css/book.css" type="text/css">   </head>   <body>      <h1>KeY</h1>      <p>         <a href="http://www.key-project.org" target="_blank">KeY</a> is a semi-automatic verification tool which allows to prove the correctness of sequential Java programs specified with JML.      </p>      <p>         The relevant knowledge for this evaluation about KeY is explained in the following sections.         <b>Please read them carefully before you continue.</b>         If you are familiar with KeY, you can skip sections you know well.         <ul>            <li><a href="#screencast">1 Screencast</a></li>            <li><a href="#proving">2 Proving with KeY</a></li>            <li><a href="#javaDL">3 Java Dynamic Logic</a></li>            <li>               <a href="#ui">4 KeY's User Interface</a>               <ul>                  <li><a href="#goals">4.1 Jump to a Goal</a></li>                  <li><a href="#hide">4.2 Hide intermediate Proofsteps</a></li>                  <li><a href="#appliedContracts">4.3 List applied Contracts</a></li>               </ul>            </li>            <li><a href="#best">5 Best Practices to understand a Proof Attempt using KeY</a></li>         </ul>      </p>      <h2><a name="screencast">1 Screencast</a></h2>      <video width="1280" height="720" poster="KeY/videos/KeYScreencast.png" controls>         <source src="KeY/videos/KeYScreencast.mp4" type="video/mp4"></source>         <source src="KeY/videos/KeYScreencast.ogv" type="KeY/videos/ogg"></source>         <source src="KeY/videos/KeYScreencast.webm" type="KeY/videos/webm"></source>         <dl>            <a href="KeY/videos/KeYScreencast.mp4">               <dt><img src="KeY/videos/KeYScreencast.png" alt="Download Video" title="Download Video" width="1280" height="720"></dt>               <dd>Download Video</dt>            </a>         </dl>      </video>            <h2><a name="proving">2 Proving with KeY</a></h2>    <p>    To verify if a Java program adheres to its JML specification,    KeY translates both into a formula in <i>Java Dynamic    Logic</i>. If KeY can prove that the formula is valid, then    the program respects its specification.         </p>    <p> For the actual verification, KeY uses a Gentzen-style    sequent calculus. The main data structure of such a calculus    is a sequent as explained in section <a href="#javaDL">2 Java Dynamic Logic</a>.        The verification process (construction of a proof) consists of         the application of syntactical rules    that transform one sequent into a set of other sequents.             This forms a so called <i>proof tree</i>. The leaves of the proof tree on which no rule is applied yet are called <i>goals</i>.         A proof is successful, if all leaves of the proof tree evaluate to true. A successful proof is called <i>closed</i>.      </p>      <p>         Rules can be applied interactively or automatically. In many         cases the automatic proof search (implemented by a so         called strategy) is powerful enough to close a proof         automatically, if program and specification are correct.    If the automatic proof search stops and the current proof is         still open, the reason can be manyfold, for instance:          <ul>           <li>              The analyzed program is buggy which caused a state in which the Java program does not fulfill its specification.              In this case implementation or specification needs to be corrected.           </li>           <li>              The strategy was stopped to early or is not powerful enough to close the proof automatically.               In this case it is possible to close the proof interactively.           </li>         </ul>      </p>            <h2><a name="javaDL">3 Java Dynamic Logic</a></h2>      <p>         The following figure shows how a sequent in Java Dynamic Logic looks like:      </p>      <img src="KeY/Sequent.png" />      <p>          A sequent consists of first-order formulas and can be read as:          Assuming that all formulas on the left side of the implication <code>==></code> hold, at least one formula on the right side needs to hold.         The left side contains typically preconditions to assume while the right side contains postconditions to be proven.      </p>      <p>         Within a sequent, the Java program to execute is contained in a diamond or box modality.         A diamond modality <code>\&lt;javaProgram\&gt; postcondition</code> evaluates to true, if the java program terminates in a state which fulfills the postcondition.         The box modality <code>\[javaProgram\] postcondition</code> evaluates additionally to true, if the java program never terminates or terminates with a thrown exception.      </p>      <p>         Rules applied on a modality symbolically execute the first active Java statement.         Resulting state changes are represented by so called updates of the form <code>{variable_1 := value_1 || ... || variable_n := value_n} formula</code>.          The meaning is that the formula is evaluated in a state where each variable has the specified value.      </p>      <p>         The heap containing Java objects is represented in a sequent by a variable named <code>heap</code>.          Modifications on a heap in the form of created objects or changed instance fields are listed in square brackets and applied in order.         Consider for instance the following update:         <code>            <pre>{heapAtPre:=heap || heap:=heap[create(newObj)]                               [newObj.intField := 42]}</pre></code>         The right part of the update creates a new object <code>newObj</code> on the heap and sets then its instance field <code>intField</code> to <code>42</code>.         The left part of the update stores the initial state of the heap (before <code>newObj</code> is created) in variable <code>heapAtPre</code>.      </p>      <p>         After application of a method contract or a loop invariant the <code>anon(locations, anotherHeap)</code> function is used to assign fresh symbolic values to all specified locations (see <code>assignable</code> clause in JML).         Technically, the locations are assigned with the value they have in <code>anotherHeap</code>. The other heap is in this evaluation always a fresh heap nothing is known about.      </p>      <p>         Field accesses within formulas either specify the target heap or target the heap named <code>heap</code> otherwise.          The following formula for instance says that in the state specified by the update the value of <code>intField</code>          in heap <code>heapAtPre</code> is the same as on the default heap <code>heap</code>.         <code>            <pre>{heapAtPre:=heap}   (obj.intField@heapAtPre = obj.intField);</pre></code>      </p>            <h2><a name="ui">4 KeY's User Interface</a></h2>      <p>         KeY is launched in a separate shell and is not integrated in Eclipse. The user interface is separated into three parts:         <ul>            <li><i>Proofs</i> shows the currently available proofs.</li>            <li>Tab <i>Proof</i> shows the proof tree and allows to switch between proof nodes.</li>            <li><i>Current Goal</i> shows the sequent of the selected proof node.</li>         </ul>      </p>      <img src="KeY/KeY_UI.png" />      <h3><a name="goals">4.1 Jump to a Goal</a></h3>      <p>         You can easily switch to goals by:         <ol>            <li>Selecting tab <i>Goals</i>.</li>            <li>Selecting the goal of interest.</li>            <li>Optionally, selecting tab <i>Proof</i>.</li>         </ol>      </p>      <img src="KeY/KeY_Goal.png" />            <h3><a name="hide">4.2 Hide intermediate Proofsteps</a></h3>      <p>         You can hide intermediate proofsteps via context menu item <i>Hide intermediate Proofsteps</i> in tab <i>Proof</i>.      </p>      <img src="KeY/KeY_Intermediate.png" />            <h3><a name="appliedContracts">4.3 List applied Contracts</a></h3>      <p>         KeY lists all applied contracts during prove by selecting main menu item 'Proof, Show Used Contracs'.      </p>      <img src="KeY/KeY_UsedContracts.png" />      <h2><a name="best">5 Best Practices to understand a Proof Attempt using KeY</a></h3>      <ol>         <li>Focus on a goal.</li>         <li>Inspect the parent nodes of the goal to comprehend             <ol>                <li>the followed execution path.</li>                <li>the parts of the postcondition which                   <ol>                      <li>could be proven and</li>                      <li>are currently still open.</li>                   </ol>                </li>             </ol>         </li>      </ol>   </body></html>